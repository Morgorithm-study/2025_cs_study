# 시간복잡도 (Time Complexity)

 문제를 해결하기 위한 연산 횟수로, 알고리즘 선택의 기준이 된다.

 ( 연산 1억 번 → 1초로 간주 )

**정의 유형**

1. Big-Omega : 최선일 때(best case) 의 연산 횟수를 나타내는 표기법
2. Big-Theta : 보통일 때(average case)의 연산 횟수를 나타내는 표기법
3. **Big-O** : 최악일 때(worst case)의 연산 횟수를 나타낸 표기법 → ⭐ **가장 많이 사용**

**Big-O를 주로 사용하는 이유**

- 최악의 상황에서의 성능 보장
- 최선 or 평균은 상황에 따라 달라지므로 일반화 어려움 (Ex : 데이터가 항상 정렬되어 있는 것은 아님)

→ 따라서 **안정적 성능 보장이 가능한 Big-O가 사용됨**

**O(1)은 O(N^2) 보다 무조건적으로 빠른가?**

- 항상 그렇지는 않다. 입력크기 N이 작으면 O(N^2)도 빠르게 실행 가능
- O(1)이어도 내부 연산이 복잡하면 느릴 수 있음.
- 하지만 N이 커질수록 O(1)은 O(N^2)보다 효율적

→ 즉, **이론적으로는 O(1)이 우위**지만, **실제로는 입력 크기와 상황을 함께 고려해야 함**

# 공간복잡도

프로그램을 해결하는 동안 필요로 하는 메모리 공간의 양. 

메모리 사용량이 적을수록 더 많은 데이터를 처리 가능하기 때문에 효율적인 알고리즘이다.

- 변수 ( int i, int sum )
- 배열
- 리스트, 트리 등 동적 자료구조
- 재귀 호출의 스택 메모리

등이 포함 된다.

**예제 코드**

```java
int n = 100;
int[] arr = new int[n];

for (int i = 0; i < n; i++) {
    arr[i] = i;
}
```

시간 복잡도 : O(N) → 배열의 길이만큼 반복문 실행

공간 복잡도 : O(N)

- int n - O(1)
- int i - O(1)
- int[] arr = new int[n] 
→ **배열 크기가 n에 따라 증가**하므로 **O(N)**
